library(tidyverse)
library(rentrez)
library(future)
library(furrr)
library(data.table)

source("R/GCA2Lins.R")

# https://stackoverflow.com/questions/18730491/sink-does-not-release-file
sink.reset <- function(){
  for(i in seq_len(sink.number())){
    sink(NULL)
  }
}


acc2lin <- function(accessions,  assembly_path, lineagelookup_path,ipgout_path = NULL )
{
  #'@author Samuel Chen
  #'@description This function combines 'efetch_ipg()' and 'ipg2lin()' to map a set
  #'of protein accessions to their assembly (GCA_ID), tax ID, and lineage.
  #'@param accessions Character vector of protein accessions
  #'@param assembly_path String of the path to the assembly_summary path
  #'This file can be generated using the "DownloadAssemblySummary()" function
  #'@param lineagelookup_path String of the path to the lineage lookup file
  #'(taxid to lineage mapping). This file can be generated using the
  #'@param ipgout_path Path to write the results of the efetch run of the accessions
  #'on the ipg database. If NULL, the file will not be written. Defaults to NULL
  tmp_ipg = F
  if(is.null(ipgout_path))
  {
    tmp_ipg = T
    ipgout_path = tempfile("ipg", fileext =".txt")
  }
  efetch_ipg(accessions, out_path= ipgout_path )

  lins <- ipg2lin(accessions, ipgout_path, assembly_path, lineagelookup_path)

  if(tmp_ipg)
  {
    unlink(tempdir(), recursive = T)
  }

  return(lins)
}



efetch_ipg <- function(accNum_vec, out_path)
{
  #'@author Samuel Chen
  #'@description Perform efetch on the ipg database and write the results to out_path
  #'@param accNum_vec Character vector containing the accession numbers to query on
  #'the ipg database
  #'@param out_path Path to write the efetch results to
  if(length(accNum_vec) > 0){

    partition <- function(v, groups){
      # Partition data to limit number of queries per second for rentrez fetch:
      # limit of 10/second w/ key
      l <- length(v)

      partitioned <- list()
      for(i in 1:groups)
      {
        partitioned[[i]] <- v[seq.int(i,l,groups)]
      }

      return(partitioned)
    }

    plan(strategy = "multiprocess", .skip = T)


    min_groups = length(accNum_vec)/250
    groups <- min(max(min_groups,15) ,length(accNum_vec))
    partitioned_acc <- partition(accNum_vec, groups )
    sink(out_path)

    a <- future_map(1:length(partitioned_acc), function(x)
    {
      # Avoid hitting the rate API limit
      if(x%%10 == 0)
      {
        Sys.sleep(1)
      }
        cat(
          entrez_fetch(id = partitioned_acc[[x]],
                       db = "ipg",
                       rettype = "xml",
                       api_key = "55120df9f5dddbec857bbb247164f86a2e09"
          )
        )
    })
    sink(NULL)
  }
}

ipg2lin <- function(accessions, ipg_file, assembly_path, lineagelookup_path)
{
  #'@author Samuel Chen
  #'@description Takes the resulting file of an efetch run on the ipg database and
  #'append lineage, and taxid columns
  #'@param accessions Character vector of protein accessions
  #'@param ipg_file Filepath to the file containing results of an efetch run on the
  #'ipg database. The protein accession in 'accessions' should be contained in this
  #'file
  #'@param assembly_path String of the path to the assembly_summary path
  #'This file can be generated using the "DownloadAssemblySummary()" function
  #'@param lineagelookup_path String of the path to the lineage lookup file
  #'(taxid to lineage mapping). This file can be generated using the
  #'"create_lineage_lookup()" function
  ipg_dt <- fread(ipg_file, sep = "\t", fill = T)

  ipg_dt <- ipg_dt[Protein %in% accessions]

  ipg_dt <- setnames(ipg_dt, "Assembly", "GCA_ID")

  lins <- GCA2Lins(prot_data = ipg_dt, assembly_path, lineagelookup_path)
  return(lins)
}





# efetch_ipg <- function(accNum_vec, outpath)
# {
#   SIZE = 250
#   lower_bound = 1
#   groups = ceiling(length(accNum_vec)/250)
#   for(i in 1:groups)
#   {
#     upper_bound = min((lower_bound+250),length(accNum_vec))
#
#     sub_acc = accNum_vec[lower_bound:upper_bound]
#
#     lower_bound = upper_bound +1
#
#     # Post needs things UID's, and doesn't really take AccNums
#     if(i == 1)
#     {
#       acc_webhistory <- entrez_post(db = "ipg", id =  sub_acc,api_key = "55120df9f5dddbec857bbb247164f86a2e09")
#     }
#     else
#     {
#       acc_webhistory <- entrez_post(db = "ipg", id =  sub_acc, web_history = acc_webhistory,
#                                     api_key = "55120df9f5dddbec857bbb247164f86a2e09")
#     }
#   }
#   browser()
#   sink(outpath)
#   cat(entrez_fetch("ipg", rettype = "xml", web_history =  acc_webhistory))
#   sink(NULL)
# }